<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>SDSGC-information-tool: Filter Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">SDSGC-information-tool
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('namespace_filter.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">Filter Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_filter_1_1_condition_function.html">ConditionFunction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struct_filter_1_1_condition_function.html" title="ConditionFunction lets me easily name and call conditions at runtime.">ConditionFunction</a> lets me easily name and call conditions at runtime.  <a href="struct_filter_1_1_condition_function.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_filter_1_1_operation.html">Operation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struct_filter_1_1_operation.html" title="Operation lets me easily name and call operations at runtime.">Operation</a> lets me easily name and call operations at runtime.  <a href="struct_filter_1_1_operation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ae86005fadaaaa2efd6b3849ee0a1ffb0"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_filter.html#ae86005fadaaaa2efd6b3849ee0a1ffb0">Condition</a> = std::function&lt; bool(const <a class="el" href="struct_hero.html">Hero</a> &amp;)&gt;</td></tr>
<tr class="separator:ae86005fadaaaa2efd6b3849ee0a1ffb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ab5e0f04c95f8029d447a59fca10ce176"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::array&lt; <a class="el" href="struct_hero.html">Hero</a>, Heroes::COUNT &gt;::iterator &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_filter.html#ab5e0f04c95f8029d447a59fca10ce176">Filter</a> ()</td></tr>
<tr class="memdesc:ab5e0f04c95f8029d447a59fca10ce176"><td class="mdescLeft">&#160;</td><td class="mdescRight">An interactive menu to filter heroes, including combining as many conditions as you want. Also prints the conditions selected in the order, left-to-right, that they are evaluated. (This function is called by the main menu function <a class="el" href="namespace_filter.html">Filter</a>.)  <a href="namespace_filter.html#ab5e0f04c95f8029d447a59fca10ce176">More...</a><br /></td></tr>
<tr class="separator:ab5e0f04c95f8029d447a59fca10ce176"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafd91ab8f6c8ea4b822bf1539f0796c1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_filter.html#ae86005fadaaaa2efd6b3849ee0a1ffb0">Condition</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_filter.html#aafd91ab8f6c8ea4b822bf1539f0796c1">GetCondition</a> (std::queue&lt; std::string &gt; &amp;filters)</td></tr>
<tr class="memdesc:aafd91ab8f6c8ea4b822bf1539f0796c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">An interactive menu to choose one condition to filter.  <a href="namespace_filter.html#aafd91ab8f6c8ea4b822bf1539f0796c1">More...</a><br /></td></tr>
<tr class="separator:aafd91ab8f6c8ea4b822bf1539f0796c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa91fe22f3ed0e9c104ac25e474bf7a6e"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_filter.html#aa91fe22f3ed0e9c104ac25e474bf7a6e">GetArguments</a> (size_t int_input)</td></tr>
<tr class="memdesc:aa91fe22f3ed0e9c104ac25e474bf7a6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function that handles deciding which conditions need which arguments, and then calls AskForArguments.  <a href="namespace_filter.html#aa91fe22f3ed0e9c104ac25e474bf7a6e">More...</a><br /></td></tr>
<tr class="separator:aa91fe22f3ed0e9c104ac25e474bf7a6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebdf216433962af1880b2fd45636dd3d"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_filter.html#aebdf216433962af1880b2fd45636dd3d">AskForArguments</a> (std::string name, std::vector&lt; std::string &gt; options, size_t count)</td></tr>
<tr class="memdesc:aebdf216433962af1880b2fd45636dd3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">An interactive menu to choose the arguments for conditions that need them (in, currently, a limited way).  <a href="namespace_filter.html#aebdf216433962af1880b2fd45636dd3d">More...</a><br /></td></tr>
<tr class="separator:aebdf216433962af1880b2fd45636dd3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab987400dfc0a7807e76c274ed2ac15ac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_filter.html#ae86005fadaaaa2efd6b3849ee0a1ffb0">Condition</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_filter.html#ab987400dfc0a7807e76c274ed2ac15ac">GetOperation</a> (<a class="el" href="namespace_filter.html#ae86005fadaaaa2efd6b3849ee0a1ffb0">Condition</a> &amp;condition, bool &amp;sentinel_finished, std::queue&lt; std::string &gt; &amp;filters)</td></tr>
<tr class="memdesc:ab987400dfc0a7807e76c274ed2ac15ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">An interactive menu to choose an operation (if any) to apply to the condition. Then calls HandleOperation to apply it, including asking for another condition if needed.  <a href="namespace_filter.html#ab987400dfc0a7807e76c274ed2ac15ac">More...</a><br /></td></tr>
<tr class="separator:ab987400dfc0a7807e76c274ed2ac15ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3620bd558f14b46f0240f78e714713f8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_filter.html#ae86005fadaaaa2efd6b3849ee0a1ffb0">Condition</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_filter.html#a3620bd558f14b46f0240f78e714713f8">HandleOperation</a> (<a class="el" href="namespace_filter.html#ae86005fadaaaa2efd6b3849ee0a1ffb0">Condition</a> &amp;condition, <a class="el" href="struct_filter_1_1_operation.html">Operation</a> operation, std::queue&lt; std::string &gt; &amp;filters)</td></tr>
<tr class="memdesc:a3620bd558f14b46f0240f78e714713f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function that takes the operation to be applied, and handles it. Calls GetCondition to ask for another condition if needed.  <a href="namespace_filter.html#a3620bd558f14b46f0240f78e714713f8">More...</a><br /></td></tr>
<tr class="separator:a3620bd558f14b46f0240f78e714713f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Conditions</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>All conditions take a list of arguments, and return a Condition. The first few conditions are straightforwardly the hero data fields. All the conditions are hardcoded in the list conditions. The list needs to stay updated - it's what the program uses. </p>
</div></td></tr>
<tr class="memitem:a735b0709a3fb4754b4717d53feb9ed83"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_filter.html#ae86005fadaaaa2efd6b3849ee0a1ffb0">Condition</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_filter.html#a735b0709a3fb4754b4717d53feb9ed83">Attribute</a> (const std::vector&lt; std::string &gt; &amp;arguments)</td></tr>
<tr class="separator:a735b0709a3fb4754b4717d53feb9ed83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa347e5a2d80b0c25a5ce3cb0f3e32cc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_filter.html#ae86005fadaaaa2efd6b3849ee0a1ffb0">Condition</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_filter.html#afa347e5a2d80b0c25a5ce3cb0f3e32cc">StartingGrade</a> (const std::vector&lt; std::string &gt; &amp;arguments)</td></tr>
<tr class="separator:afa347e5a2d80b0c25a5ce3cb0f3e32cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f44794793a39bb922b783e60f1cdd9d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_filter.html#ae86005fadaaaa2efd6b3849ee0a1ffb0">Condition</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_filter.html#a0f44794793a39bb922b783e60f1cdd9d">Character</a> (const std::vector&lt; std::string &gt; &amp;arguments)</td></tr>
<tr class="separator:a0f44794793a39bb922b783e60f1cdd9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50a556a35dd0d442f8e397e34b2b2fde"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_filter.html#ae86005fadaaaa2efd6b3849ee0a1ffb0">Condition</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_filter.html#a50a556a35dd0d442f8e397e34b2b2fde">LR</a> (const std::vector&lt; std::string &gt; &amp;arguments)</td></tr>
<tr class="separator:a50a556a35dd0d442f8e397e34b2b2fde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8e8f0956d5a6af4ba4d5af4cdbc9458"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_filter.html#ae86005fadaaaa2efd6b3849ee0a1ffb0">Condition</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_filter.html#ab8e8f0956d5a6af4ba4d5af4cdbc9458">Race</a> (const std::vector&lt; std::string &gt; &amp;arguments)</td></tr>
<tr class="separator:ab8e8f0956d5a6af4ba4d5af4cdbc9458"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4252629c4cfef3213323ab3fbd0ecb9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_filter.html#ae86005fadaaaa2efd6b3849ee0a1ffb0">Condition</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_filter.html#aa4252629c4cfef3213323ab3fbd0ecb9">Characteristic</a> (const std::vector&lt; std::string &gt; &amp;arguments)</td></tr>
<tr class="separator:aa4252629c4cfef3213323ab3fbd0ecb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7265d3c80c05ee71688e14e8ac4cb7c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_filter.html#ae86005fadaaaa2efd6b3849ee0a1ffb0">Condition</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_filter.html#ab7265d3c80c05ee71688e14e8ac4cb7c">Good</a> (const std::vector&lt; std::string &gt; &amp;arguments)</td></tr>
<tr class="separator:ab7265d3c80c05ee71688e14e8ac4cb7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a580f17444cdff1215038a26f9120ea42"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_filter.html#ae86005fadaaaa2efd6b3849ee0a1ffb0">Condition</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_filter.html#a580f17444cdff1215038a26f9120ea42">AvailableByMethod</a> (const std::vector&lt; std::string &gt; &amp;arguments)</td></tr>
<tr class="separator:a580f17444cdff1215038a26f9120ea42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6befb01643d6bdb33257f76be15342f1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_filter.html#ae86005fadaaaa2efd6b3849ee0a1ffb0">Condition</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_filter.html#a6befb01643d6bdb33257f76be15342f1">Owned</a> (const std::vector&lt; std::string &gt; &amp;arguments)</td></tr>
<tr class="separator:a6befb01643d6bdb33257f76be15342f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7e67a6f85d0aaa587cabee1a602d366"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_filter.html#ae86005fadaaaa2efd6b3849ee0a1ffb0">Condition</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_filter.html#af7e67a6f85d0aaa587cabee1a602d366">Upgraded</a> (const std::vector&lt; std::string &gt; &amp;arguments)</td></tr>
<tr class="separator:af7e67a6f85d0aaa587cabee1a602d366"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac47111a7e5d261053d4e24afc38d60ba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_filter.html#ae86005fadaaaa2efd6b3849ee0a1ffb0">Condition</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_filter.html#ac47111a7e5d261053d4e24afc38d60ba">Acquirable</a> (const std::vector&lt; std::string &gt; &amp;arguments)</td></tr>
<tr class="separator:ac47111a7e5d261053d4e24afc38d60ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Operations</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>All operations take a list of Conditions, and return a Condition. All the operations are hardcoded in the list operations. The list needs to stay updated - it's what the program uses. </p>
</div></td></tr>
<tr class="memitem:a540dce631a289a8cada31c26b8f02978"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_filter.html#ae86005fadaaaa2efd6b3849ee0a1ffb0">Condition</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_filter.html#a540dce631a289a8cada31c26b8f02978">And</a> (const std::vector&lt; <a class="el" href="namespace_filter.html#ae86005fadaaaa2efd6b3849ee0a1ffb0">Condition</a> &gt; &amp;<a class="el" href="namespace_filter.html#a04c347e7a45c34d83cbd91702f4c1ca8">conditions</a>)</td></tr>
<tr class="separator:a540dce631a289a8cada31c26b8f02978"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5d279bdf985e78a5d67a1eb86db50fb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_filter.html#ae86005fadaaaa2efd6b3849ee0a1ffb0">Condition</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_filter.html#ad5d279bdf985e78a5d67a1eb86db50fb">Or</a> (const std::vector&lt; <a class="el" href="namespace_filter.html#ae86005fadaaaa2efd6b3849ee0a1ffb0">Condition</a> &gt; &amp;<a class="el" href="namespace_filter.html#a04c347e7a45c34d83cbd91702f4c1ca8">conditions</a>)</td></tr>
<tr class="separator:ad5d279bdf985e78a5d67a1eb86db50fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac71985fd5a2186418eb1e828491c3b30"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_filter.html#ae86005fadaaaa2efd6b3849ee0a1ffb0">Condition</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_filter.html#ac71985fd5a2186418eb1e828491c3b30">Not</a> (const std::vector&lt; <a class="el" href="namespace_filter.html#ae86005fadaaaa2efd6b3849ee0a1ffb0">Condition</a> &gt; &amp;<a class="el" href="namespace_filter.html#a04c347e7a45c34d83cbd91702f4c1ca8">conditions</a>)</td></tr>
<tr class="separator:ac71985fd5a2186418eb1e828491c3b30"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a04c347e7a45c34d83cbd91702f4c1ca8"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="struct_filter_1_1_condition_function.html">ConditionFunction</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_filter.html#a04c347e7a45c34d83cbd91702f4c1ca8">conditions</a></td></tr>
<tr class="memdesc:a04c347e7a45c34d83cbd91702f4c1ca8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hardcoded list of all conditions.  <a href="namespace_filter.html#a04c347e7a45c34d83cbd91702f4c1ca8">More...</a><br /></td></tr>
<tr class="separator:a04c347e7a45c34d83cbd91702f4c1ca8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f578b6d592f7bd4e2fbe0af42efd56b"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="struct_filter_1_1_operation.html">Operation</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_filter.html#a9f578b6d592f7bd4e2fbe0af42efd56b">operations</a></td></tr>
<tr class="memdesc:a9f578b6d592f7bd4e2fbe0af42efd56b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hardcoded list of all operations.  <a href="namespace_filter.html#a9f578b6d592f7bd4e2fbe0af42efd56b">More...</a><br /></td></tr>
<tr class="separator:a9f578b6d592f7bd4e2fbe0af42efd56b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ae86005fadaaaa2efd6b3849ee0a1ffb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae86005fadaaaa2efd6b3849ee0a1ffb0">&#9670;&nbsp;</a></span>Condition</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespace_filter.html#ae86005fadaaaa2efd6b3849ee0a1ffb0">Filter::Condition</a> = typedef std::function&lt;bool(const <a class="el" href="struct_hero.html">Hero</a> &amp;)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ac47111a7e5d261053d4e24afc38d60ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac47111a7e5d261053d4e24afc38d60ba">&#9670;&nbsp;</a></span>Acquirable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_filter.html#ae86005fadaaaa2efd6b3849ee0a1ffb0">Condition</a> Filter::Acquirable </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>arguments</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;arguments</td><td>The vector is empty. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Condition that is true if <a class="el" href="struct_hero.html" title="A hero is an object of this type; it groups information a hero has.">Hero</a> is currently acquirable. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a540dce631a289a8cada31c26b8f02978"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a540dce631a289a8cada31c26b8f02978">&#9670;&nbsp;</a></span>And()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_filter.html#ae86005fadaaaa2efd6b3849ee0a1ffb0">Condition</a> Filter::And </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespace_filter.html#ae86005fadaaaa2efd6b3849ee0a1ffb0">Condition</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>conditions</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;conditions</td><td>The vector contains 2 conditions </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of condition A AND B </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aebdf216433962af1880b2fd45636dd3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebdf216433962af1880b2fd45636dd3d">&#9670;&nbsp;</a></span>AskForArguments()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; Filter::AskForArguments </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt;&#160;</td>
          <td class="paramname"><em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An interactive menu to choose the arguments for conditions that need them (in, currently, a limited way). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the thing being asked for, e.g. "starting grade" </td></tr>
    <tr><td class="paramname">options</td><td>The list of possibilities that name can be, e.g. {"R", "SR", "SSR", "UR"} </td></tr>
    <tr><td class="paramname">count</td><td>The number of options to be selected, e.g. 1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the arguments (a vector of strings, possibly empty). </dd></dl>

</div>
</div>
<a id="a735b0709a3fb4754b4717d53feb9ed83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a735b0709a3fb4754b4717d53feb9ed83">&#9670;&nbsp;</a></span>Attribute()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_filter.html#ae86005fadaaaa2efd6b3849ee0a1ffb0">Condition</a> Filter::Attribute </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>arguments</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;arguments</td><td>The vector contains 1 string, the name of an attribute. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Condition that is true if <a class="el" href="struct_hero.html" title="A hero is an object of this type; it groups information a hero has.">Hero</a> is that attribute. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a580f17444cdff1215038a26f9120ea42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a580f17444cdff1215038a26f9120ea42">&#9670;&nbsp;</a></span>AvailableByMethod()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_filter.html#ae86005fadaaaa2efd6b3849ee0a1ffb0">Condition</a> Filter::AvailableByMethod </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>arguments</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;arguments</td><td>The vector contains 1 string, the name of a draw. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Condition that is true if <a class="el" href="struct_hero.html" title="A hero is an object of this type; it groups information a hero has.">Hero</a> is available from that draw. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0f44794793a39bb922b783e60f1cdd9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f44794793a39bb922b783e60f1cdd9d">&#9670;&nbsp;</a></span>Character()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_filter.html#ae86005fadaaaa2efd6b3849ee0a1ffb0">Condition</a> Filter::Character </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>arguments</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;arguments</td><td>The vector contains 1 string, the name of a character. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Condition that is true if <a class="el" href="struct_hero.html" title="A hero is an object of this type; it groups information a hero has.">Hero</a> is that character. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa4252629c4cfef3213323ab3fbd0ecb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4252629c4cfef3213323ab3fbd0ecb9">&#9670;&nbsp;</a></span>Characteristic()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_filter.html#ae86005fadaaaa2efd6b3849ee0a1ffb0">Condition</a> Filter::Characteristic </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>arguments</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;arguments</td><td>The vector contains 1 string, the name of a characteristic. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Condition that is true if <a class="el" href="struct_hero.html" title="A hero is an object of this type; it groups information a hero has.">Hero</a> is that characteristic. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab5e0f04c95f8029d447a59fca10ce176"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5e0f04c95f8029d447a59fca10ce176">&#9670;&nbsp;</a></span>Filter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::array&lt; <a class="el" href="struct_hero.html">Hero</a>, Heroes::COUNT &gt;::iterator &gt; Filter::Filter </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An interactive menu to filter heroes, including combining as many conditions as you want. Also prints the conditions selected in the order, left-to-right, that they are evaluated. (This function is called by the main menu function <a class="el" href="namespace_filter.html">Filter</a>.) </p>
<dl class="section return"><dt>Returns</dt><dd>a vector of iterators, pointing to the elements of the original vector. </dd></dl>

</div>
</div>
<a id="aa91fe22f3ed0e9c104ac25e474bf7a6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa91fe22f3ed0e9c104ac25e474bf7a6e">&#9670;&nbsp;</a></span>GetArguments()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; Filter::GetArguments </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>int_input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The function that handles deciding which conditions need which arguments, and then calls AskForArguments. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">int_input</td><td>The user's selection of condition </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the arguments (a vector of strings, possibly empty). </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespace_filter.html#aebdf216433962af1880b2fd45636dd3d" title="An interactive menu to choose the arguments for conditions that need them (in, currently,...">AskForArguments</a> </dd></dl>

</div>
</div>
<a id="aafd91ab8f6c8ea4b822bf1539f0796c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafd91ab8f6c8ea4b822bf1539f0796c1">&#9670;&nbsp;</a></span>GetCondition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_filter.html#ae86005fadaaaa2efd6b3849ee0a1ffb0">Condition</a> Filter::GetCondition </td>
          <td>(</td>
          <td class="paramtype">std::queue&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>filters</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An interactive menu to choose one condition to filter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;filters</td><td>Reference to a queue of conditions to keep track of them. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the condition (which is also added to the queue) </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespace_filter.html#aa91fe22f3ed0e9c104ac25e474bf7a6e" title="The function that handles deciding which conditions need which arguments, and then calls AskForArgume...">GetArguments</a> </dd></dl>

</div>
</div>
<a id="ab987400dfc0a7807e76c274ed2ac15ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab987400dfc0a7807e76c274ed2ac15ac">&#9670;&nbsp;</a></span>GetOperation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_filter.html#ae86005fadaaaa2efd6b3849ee0a1ffb0">Condition</a> Filter::GetOperation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_filter.html#ae86005fadaaaa2efd6b3849ee0a1ffb0">Condition</a> &amp;&#160;</td>
          <td class="paramname"><em>condition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>sentinel_finished</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::queue&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>filters</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An interactive menu to choose an operation (if any) to apply to the condition. Then calls HandleOperation to apply it, including asking for another condition if needed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;condition</td><td>Reference to the initial condition. </td></tr>
    <tr><td class="paramname">&amp;sentinel_finished</td><td>Track whether user is finished applying operations (i.e. set to true when they choose to get results). </td></tr>
    <tr><td class="paramname">&amp;filters</td><td>Reference to a queue of conditions to keep track of them. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the resulting condition (e.g. A AND B). </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespace_filter.html#a3620bd558f14b46f0240f78e714713f8" title="The function that takes the operation to be applied, and handles it. Calls GetCondition to ask for an...">HandleOperation</a> </dd></dl>

</div>
</div>
<a id="ab7265d3c80c05ee71688e14e8ac4cb7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7265d3c80c05ee71688e14e8ac4cb7c">&#9670;&nbsp;</a></span>Good()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_filter.html#ae86005fadaaaa2efd6b3849ee0a1ffb0">Condition</a> Filter::Good </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>arguments</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;arguments</td><td>The vector contains between 1 and 5 numbers, any ranks. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Condition that is true if <a class="el" href="struct_hero.html" title="A hero is an object of this type; it groups information a hero has.">Hero</a> is in any of those ranks on any of the tier lists. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3620bd558f14b46f0240f78e714713f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3620bd558f14b46f0240f78e714713f8">&#9670;&nbsp;</a></span>HandleOperation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_filter.html#ae86005fadaaaa2efd6b3849ee0a1ffb0">Condition</a> Filter::HandleOperation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_filter.html#ae86005fadaaaa2efd6b3849ee0a1ffb0">Condition</a> &amp;&#160;</td>
          <td class="paramname"><em>condition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_filter_1_1_operation.html">Operation</a>&#160;</td>
          <td class="paramname"><em>operation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::queue&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>filters</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The function that takes the operation to be applied, and handles it. Calls GetCondition to ask for another condition if needed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;condition</td><td>Reference to the initial condition. </td></tr>
    <tr><td class="paramname">operation</td><td>The selected operation to apply to condition. </td></tr>
    <tr><td class="paramname">&amp;filters</td><td>Reference to a queue of conditions to keep track of them. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the resulting condition (e.g. A AND B). (The operation is also added to the queue.) </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespace_filter.html#aafd91ab8f6c8ea4b822bf1539f0796c1" title="An interactive menu to choose one condition to filter.">GetCondition</a> </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if operation has non-positive 'arity' </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a50a556a35dd0d442f8e397e34b2b2fde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50a556a35dd0d442f8e397e34b2b2fde">&#9670;&nbsp;</a></span>LR()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_filter.html#ae86005fadaaaa2efd6b3849ee0a1ffb0">Condition</a> Filter::LR </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>arguments</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;arguments</td><td>The vector is empty. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Condition that is true if <a class="el" href="struct_hero.html" title="A hero is an object of this type; it groups information a hero has.">Hero</a> is upgradable to LR. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac71985fd5a2186418eb1e828491c3b30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac71985fd5a2186418eb1e828491c3b30">&#9670;&nbsp;</a></span>Not()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_filter.html#ae86005fadaaaa2efd6b3849ee0a1ffb0">Condition</a> Filter::Not </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespace_filter.html#ae86005fadaaaa2efd6b3849ee0a1ffb0">Condition</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>conditions</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;conditions</td><td>The vector contains 1 condition </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of NOT condition </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad5d279bdf985e78a5d67a1eb86db50fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5d279bdf985e78a5d67a1eb86db50fb">&#9670;&nbsp;</a></span>Or()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_filter.html#ae86005fadaaaa2efd6b3849ee0a1ffb0">Condition</a> Filter::Or </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespace_filter.html#ae86005fadaaaa2efd6b3849ee0a1ffb0">Condition</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>conditions</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;conditions</td><td>The vector contains 2 conditions </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of condition A OR B </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6befb01643d6bdb33257f76be15342f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6befb01643d6bdb33257f76be15342f1">&#9670;&nbsp;</a></span>Owned()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_filter.html#ae86005fadaaaa2efd6b3849ee0a1ffb0">Condition</a> Filter::Owned </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>arguments</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;arguments</td><td>The vector is empty. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Condition that is true if <a class="el" href="struct_hero.html" title="A hero is an object of this type; it groups information a hero has.">Hero</a> is owned. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab8e8f0956d5a6af4ba4d5af4cdbc9458"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8e8f0956d5a6af4ba4d5af4cdbc9458">&#9670;&nbsp;</a></span>Race()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_filter.html#ae86005fadaaaa2efd6b3849ee0a1ffb0">Condition</a> Filter::Race </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>arguments</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;arguments</td><td>The vector contains 1 string, the name of a race. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Condition that is true if <a class="el" href="struct_hero.html" title="A hero is an object of this type; it groups information a hero has.">Hero</a> is that race. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afa347e5a2d80b0c25a5ce3cb0f3e32cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa347e5a2d80b0c25a5ce3cb0f3e32cc">&#9670;&nbsp;</a></span>StartingGrade()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_filter.html#ae86005fadaaaa2efd6b3849ee0a1ffb0">Condition</a> Filter::StartingGrade </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>arguments</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;arguments</td><td>The vector contains 1 string, the name of a starting grade. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Condition that is true if <a class="el" href="struct_hero.html" title="A hero is an object of this type; it groups information a hero has.">Hero</a> is that starting grade. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af7e67a6f85d0aaa587cabee1a602d366"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7e67a6f85d0aaa587cabee1a602d366">&#9670;&nbsp;</a></span>Upgraded()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_filter.html#ae86005fadaaaa2efd6b3849ee0a1ffb0">Condition</a> Filter::Upgraded </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>arguments</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;arguments</td><td>The vector is empty. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Condition that is true if <a class="el" href="struct_hero.html" title="A hero is an object of this type; it groups information a hero has.">Hero</a> is owned and above level 80. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a04c347e7a45c34d83cbd91702f4c1ca8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04c347e7a45c34d83cbd91702f4c1ca8">&#9670;&nbsp;</a></span>conditions</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;<a class="el" href="struct_filter_1_1_condition_function.html">ConditionFunction</a>&gt; Filter::conditions</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= {</div>
<div class="line">    {<span class="stringliteral">&quot;Attribute&quot;</span>, <a class="code" href="namespace_filter.html#a735b0709a3fb4754b4717d53feb9ed83">Attribute</a>},</div>
<div class="line">    {<span class="stringliteral">&quot;StartingGrade&quot;</span>, <a class="code" href="namespace_filter.html#afa347e5a2d80b0c25a5ce3cb0f3e32cc">StartingGrade</a>},</div>
<div class="line">    {<span class="stringliteral">&quot;Character&quot;</span>, <a class="code" href="namespace_filter.html#a0f44794793a39bb922b783e60f1cdd9d">Character</a>},</div>
<div class="line">    {<span class="stringliteral">&quot;LR&quot;</span>, <a class="code" href="namespace_filter.html#a50a556a35dd0d442f8e397e34b2b2fde">LR</a>},</div>
<div class="line">    {<span class="stringliteral">&quot;Race&quot;</span>, <a class="code" href="namespace_filter.html#ab8e8f0956d5a6af4ba4d5af4cdbc9458">Race</a>},</div>
<div class="line">    {<span class="stringliteral">&quot;Characteristic&quot;</span>, <a class="code" href="namespace_filter.html#aa4252629c4cfef3213323ab3fbd0ecb9">Characteristic</a>},</div>
<div class="line">    {<span class="stringliteral">&quot;Good&quot;</span>, <a class="code" href="namespace_filter.html#ab7265d3c80c05ee71688e14e8ac4cb7c">Good</a>},</div>
<div class="line">    {<span class="stringliteral">&quot;Owned&quot;</span>, <a class="code" href="namespace_filter.html#a6befb01643d6bdb33257f76be15342f1">Owned</a>},</div>
<div class="line">    {<span class="stringliteral">&quot;Acquirable&quot;</span>, <a class="code" href="namespace_filter.html#ac47111a7e5d261053d4e24afc38d60ba">Acquirable</a>},</div>
<div class="line">    {<span class="stringliteral">&quot;AvailableByMethod&quot;</span>, <a class="code" href="namespace_filter.html#a580f17444cdff1215038a26f9120ea42">AvailableByMethod</a>},</div>
<div class="line">    {<span class="stringliteral">&quot;Upgraded&quot;</span>, <a class="code" href="namespace_filter.html#af7e67a6f85d0aaa587cabee1a602d366">Upgraded</a>},</div>
<div class="line">}</div>
<div class="ttc" id="anamespace_filter_html_a0f44794793a39bb922b783e60f1cdd9d"><div class="ttname"><a href="namespace_filter.html#a0f44794793a39bb922b783e60f1cdd9d">Filter::Character</a></div><div class="ttdeci">Condition Character(const std::vector&lt; std::string &gt; &amp;arguments)</div><div class="ttdef"><b>Definition:</b> Filter.cpp:205</div></div>
<div class="ttc" id="anamespace_filter_html_a50a556a35dd0d442f8e397e34b2b2fde"><div class="ttname"><a href="namespace_filter.html#a50a556a35dd0d442f8e397e34b2b2fde">Filter::LR</a></div><div class="ttdeci">Condition LR(const std::vector&lt; std::string &gt; &amp;arguments)</div><div class="ttdef"><b>Definition:</b> Filter.cpp:215</div></div>
<div class="ttc" id="anamespace_filter_html_a580f17444cdff1215038a26f9120ea42"><div class="ttname"><a href="namespace_filter.html#a580f17444cdff1215038a26f9120ea42">Filter::AvailableByMethod</a></div><div class="ttdeci">Condition AvailableByMethod(const std::vector&lt; std::string &gt; &amp;arguments)</div><div class="ttdef"><b>Definition:</b> Filter.cpp:257</div></div>
<div class="ttc" id="anamespace_filter_html_a6befb01643d6bdb33257f76be15342f1"><div class="ttname"><a href="namespace_filter.html#a6befb01643d6bdb33257f76be15342f1">Filter::Owned</a></div><div class="ttdeci">Condition Owned(const std::vector&lt; std::string &gt; &amp;arguments)</div><div class="ttdef"><b>Definition:</b> Filter.cpp:270</div></div>
<div class="ttc" id="anamespace_filter_html_a735b0709a3fb4754b4717d53feb9ed83"><div class="ttname"><a href="namespace_filter.html#a735b0709a3fb4754b4717d53feb9ed83">Filter::Attribute</a></div><div class="ttdeci">Condition Attribute(const std::vector&lt; std::string &gt; &amp;arguments)</div><div class="ttdef"><b>Definition:</b> Filter.cpp:185</div></div>
<div class="ttc" id="anamespace_filter_html_aa4252629c4cfef3213323ab3fbd0ecb9"><div class="ttname"><a href="namespace_filter.html#aa4252629c4cfef3213323ab3fbd0ecb9">Filter::Characteristic</a></div><div class="ttdeci">Condition Characteristic(const std::vector&lt; std::string &gt; &amp;arguments)</div><div class="ttdef"><b>Definition:</b> Filter.cpp:233</div></div>
<div class="ttc" id="anamespace_filter_html_ab7265d3c80c05ee71688e14e8ac4cb7c"><div class="ttname"><a href="namespace_filter.html#ab7265d3c80c05ee71688e14e8ac4cb7c">Filter::Good</a></div><div class="ttdeci">Condition Good(const std::vector&lt; std::string &gt; &amp;arguments)</div><div class="ttdef"><b>Definition:</b> Filter.cpp:243</div></div>
<div class="ttc" id="anamespace_filter_html_ab8e8f0956d5a6af4ba4d5af4cdbc9458"><div class="ttname"><a href="namespace_filter.html#ab8e8f0956d5a6af4ba4d5af4cdbc9458">Filter::Race</a></div><div class="ttdeci">Condition Race(const std::vector&lt; std::string &gt; &amp;arguments)</div><div class="ttdef"><b>Definition:</b> Filter.cpp:222</div></div>
<div class="ttc" id="anamespace_filter_html_ac47111a7e5d261053d4e24afc38d60ba"><div class="ttname"><a href="namespace_filter.html#ac47111a7e5d261053d4e24afc38d60ba">Filter::Acquirable</a></div><div class="ttdeci">Condition Acquirable(const std::vector&lt; std::string &gt; &amp;arguments)</div><div class="ttdef"><b>Definition:</b> Filter.cpp:288</div></div>
<div class="ttc" id="anamespace_filter_html_af7e67a6f85d0aaa587cabee1a602d366"><div class="ttname"><a href="namespace_filter.html#af7e67a6f85d0aaa587cabee1a602d366">Filter::Upgraded</a></div><div class="ttdeci">Condition Upgraded(const std::vector&lt; std::string &gt; &amp;arguments)</div><div class="ttdef"><b>Definition:</b> Filter.cpp:277</div></div>
<div class="ttc" id="anamespace_filter_html_afa347e5a2d80b0c25a5ce3cb0f3e32cc"><div class="ttname"><a href="namespace_filter.html#afa347e5a2d80b0c25a5ce3cb0f3e32cc">Filter::StartingGrade</a></div><div class="ttdeci">Condition StartingGrade(const std::vector&lt; std::string &gt; &amp;arguments)</div><div class="ttdef"><b>Definition:</b> Filter.cpp:195</div></div>
</div><!-- fragment -->
<p>Hardcoded list of all conditions. </p>

</div>
</div>
<a id="a9f578b6d592f7bd4e2fbe0af42efd56b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f578b6d592f7bd4e2fbe0af42efd56b">&#9670;&nbsp;</a></span>operations</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;<a class="el" href="struct_filter_1_1_operation.html">Operation</a>&gt; Filter::operations</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= {</div>
<div class="line">    {<span class="stringliteral">&quot;And&quot;</span>, <a class="code" href="namespace_filter.html#a540dce631a289a8cada31c26b8f02978">And</a>, 2}, {<span class="stringliteral">&quot;Or&quot;</span>, <a class="code" href="namespace_filter.html#ad5d279bdf985e78a5d67a1eb86db50fb">Or</a>, 2}, {<span class="stringliteral">&quot;Not&quot;</span>, <a class="code" href="namespace_filter.html#ac71985fd5a2186418eb1e828491c3b30">Not</a>, 1}}</div>
<div class="ttc" id="anamespace_filter_html_a540dce631a289a8cada31c26b8f02978"><div class="ttname"><a href="namespace_filter.html#a540dce631a289a8cada31c26b8f02978">Filter::And</a></div><div class="ttdeci">Condition And(const std::vector&lt; Condition &gt; &amp;conditions)</div><div class="ttdef"><b>Definition:</b> Filter.cpp:297</div></div>
<div class="ttc" id="anamespace_filter_html_ac71985fd5a2186418eb1e828491c3b30"><div class="ttname"><a href="namespace_filter.html#ac71985fd5a2186418eb1e828491c3b30">Filter::Not</a></div><div class="ttdeci">Condition Not(const std::vector&lt; Condition &gt; &amp;conditions)</div><div class="ttdef"><b>Definition:</b> Filter.cpp:315</div></div>
<div class="ttc" id="anamespace_filter_html_ad5d279bdf985e78a5d67a1eb86db50fb"><div class="ttname"><a href="namespace_filter.html#ad5d279bdf985e78a5d67a1eb86db50fb">Filter::Or</a></div><div class="ttdeci">Condition Or(const std::vector&lt; Condition &gt; &amp;conditions)</div><div class="ttdef"><b>Definition:</b> Filter.cpp:306</div></div>
</div><!-- fragment -->
<p>Hardcoded list of all operations. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespace_filter.html">Filter</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
